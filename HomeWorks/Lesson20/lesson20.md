[Официальная док-ция](https://www.postgresql.org/docs/14/ddl-partitioning.html)

Получить и вести секционирование таблицы, в пг, можно двумя способами.
Первый и - старый (до 10-й версии пг) механизм: триггерный.
И новый, с версии 10: так называемый - нативный, или - декларативный.

Сначала про общее для обоих вариантов секционирования.
В обоих вариантах партиционирование выполняется с использованием понятия: парент-таблица и её таблицы-партиции.
Пример (триггерное секционирование):
```sql
CREATE TABLE logs (id serial, created_at timestamp without time zone);
CREATE TABLE logs_old (CHECK ( created_at < '2020-01-01' ) ) INHERITS(logs);
CREATE TABLE logs_202001( CHECK ( created_at >= '2020-01-01' and created_at < '2020-02-01' )) INHERITS(logs);
...
CREATE TABLE logs_202012 ( CHECK ( created_at >= '2020-12-01' and created_at < '2021-01-01' )) INHERITS(logs);
```

Соотв-но есть понятие наследования: таблиц-партиции наследуют констрейнты, индексы от парент-таблицы и парент-таблица - как бы объявляет структуру партиционированной таблицы.
Как обычно - ключ секционирования: должен быть not null;
Как обычно - pk/uk-констрейнты, на партиционированную таблицу (и, соотв-но, pk/uk-индексы): обязаны включать в себя ключ секционирования таблицы (пункт `5.11.2.3. Limitations` [доки](https://www.postgresql.org/docs/14/ddl-partitioning.html#DDL-PARTITIONING-OVERVIEW)).
Как обычно - ключ секционирования, если это диапазонное, или списковое секционирование, в каждой партиции (с некоторыми оговорками), желательно обвешивать check-констрейнтами.
Нужно для того чтобы:
1. Гарантированно перекрыть возможность попадания/оставления строки не "в свою" партицию: check-констрейнт просто не пропустит, то что, по дизайну, не должно быть в данной партиции.
   Так называемый `constraint_exclusion`
2. При состоянии active-validate (правда, не уверен - есть/не есть такое в пг): база, этим check-констрейнтом, информируется, о том что именно есть, в данной партиции, в ключе секуионирования.
   И, например при аттачах партиции к парент-таблице: не выполняет валидацию фактических значений ключей секционирования строк, в партиции.
   Что, для больших партиций - весьма актуально.
   Партишен-прунинг, для триггер-базед варианта секционирования, может сработать только на этих check-ах, если они есть и если есть диапазонный предикат, в where-предложении sql-команды, на ключ секционирования.
   Соотв-но тут ещё - крайне желателен индекс, на ключ-секционирования.

Оговорка, с пространным отступлением в декларативное секционирование, такая: в декларативном секционировании появилась так называемая дефолтная партиция.
Пример, именно декларативного секционирования ([отсюда](https://severalnines.com/blog/how-take-advantage-new-partitioning-features-postgresql-11/)):
```sql
CREATE TABLE customers(cust_id bigint NOT NULL,cust_name varchar(32) NOT NULL,cust_address text,
cust_country text)PARTITION BY LIST(cust_country);
CREATE TABLE customer_ind PARTITION OF customers FOR VALUES IN ('ind');
CREATE TABLE customer_jap PARTITION OF customers FOR VALUES IN ('jap');
CREATE TABLE customers_def PARTITION OF customers DEFAULT;
```

Дефолтная партиция - нужна для сохранения строк, которые не мапятся, по своему значению ключа секционирования, ни в какие другие партиции.
Правда, если дефолтная таблица - есть, и в ней есть какие то строки, например, в контексте примера выше:
```sql
UPDATE customers1 SET cust_country ='usa' WHERE cust_id=2039;
```
То, если создавать специальную партицию под `cust_country='usa'` - надо будет, сначала, куда то сохранить и удалить строки с `cust_country='usa'` из дефолтной партиции.
Иначе - не даст создать партицию.
Ну и, поскольку, если дефолтная партиция - есть и, поскольку, не известно заранее - какие именно значения ключа секционирования в её строках будут (если будут) то check-констрейнт на эту партицию, на столбец(ы) являющиеся ключами секционирования - повесить затруднительно.
Кстати это обозначает что, при добавлении новых партиций, дефаулт-секция, если она есть - будет сканится полностью.
На предмет проверки - а вдруг там есть записи, со значением(ами) ключей секционирования такими, какими они д.б. в новой партиции.
Поэтому, если check-констрейнт, на дефаулт-секцию, на ключ секционирования повесить затруднительно, то, хотя бы, индекс должен быть.

Ещё один момент, который, тоже, будет трудно поддаваться обвешиванию check-ами: партиции, в декларативном секционировании, которые могут быть объявлены, с опциями `minvalue` и/или `maxvalue`
Ну и видимо - такая же будет история, если надо будет добавить партицию под значение ключа, под которое уже есть строки в партициях с maxvalue/minvalue;

Можно, в обоих вариантах секционирования, навешивать какие то свои индексы, констрейнты, на таблицы-партиции.
При этом, опять, отступление в декларативное секционирование, в [доке](https://www.postgresql.org/docs/14/ddl-partitioning.html#DDL-PARTITIONING-OVERVIEW) есть такое интересное замечание, в пункте `5.11.2.2. Partition Maintenance`, про такие - дополнительные индексы.
Дело в том что в пг - можно создавать индексы с опцией `CONCURRENTLY` ([дока](https://www.postgresql.org/docs/14/sql-createindex.html#SQL-CREATEINDEX-CONCURRENTLY)) - это аналог online-опции, в oracle-субд.
Т.е. - без эксклюзивного лока, на индексируемую таблицу, вместе с дмл-операциями.
В пг, правда, CONCURRENTLY-опция стоит сильно дороже, чем в оракле, потому что, про себя, она потребует двойного сканирования ииндексируемой таблицы.
Типа, сначала создаётся индекс, при первом сканировании.
Потом дожидается завершения текущих, на момент первого сканирования, транзакций и делает второе сканирование - для уточнения индексных элементов в индексе.

Так вот оказывается что CONCURRENTLY-опцию: нельзя применять, для создания вторичных индексов (global-индексов, т.е.: на всю партиционированную таблицу. На конкретную таблицу-партицию - можно) на партиционированную таблицу.
Но есть объездной вариант, пример, из доки:
```sql
CREATE TABLE measurement (
    city_id         int not null,
    logdate         date not null,
    peaktemp        int,
    unitsales       int
) PARTITION BY RANGE (logdate);
...
CREATE INDEX measurement_usls_idx ON ONLY measurement (unitsales);
...
CREATE TABLE measurement_y2006m02 PARTITION OF measurement FOR VALUES FROM ('2006-02-01') TO ('2006-03-01');
...
CREATE INDEX measurement_usls_200602_idx ON measurement_y2006m02 (unitsales); --можно с CONCURRENTLY-опцией
ALTER INDEX measurement_usls_idx ATTACH PARTITION measurement_usls_200602_idx;
...
```
Особенность тут в том что по ONLY-опции индекс объявляется только на парент-таблицу, которая типа - пустая.
И такой индекс, на парент-таблицу, сразу после создания помечается инвалидным.
Затем на какую то таблицу-партицю, на тот же индексируемый столбец, вешается индекс и аттачится, как партиция индекса, к индексу на паретн-таблицу (в пг, технически, индексы - тоже таблицы).
Сам аттач, понятно - это быстро, это никакая не обработка каких то табличных строк.
И вот после аттача - глобальный индекс - помечается валидным.

Немного про старый/новый вариант секционирования.
Смысл триггерного варианта, вкратце, в том что движение строк, в и между партициями, при, соотв-но, инсертах/апдейтах, выполняется for-each-row дмл-триггером.
Т.е.: некто - определяет практически всё:
Набор таблиц: парент-таблица и таблиц-партиции, индексы, констрейнты.
И определяет триггер.
[Шикарный и подробный пример](https://juanitofatas.com/series/postgres/partitioning) об этом варианте получения партиционированной таблицы.

В дальнейшем - вот этот весь набор объектов: так и живёт, такой, какой он был определён.
Т.е. новые партиции автоматом - не создаются, если вставляется, или, по итогу какого то апдейта - получается строка с таким значением ключа секционирования, под которое ни одна из уже существующих партиций - не попадает.
Тогда, такая строка - сохраняется в парент-таблицу.
Дефолт-партиции, maxvalue/minvalue определения диапазона ключа секционирования, для партиции, в триггерном мех-ме - нет.
Кстати, в декларативном варианте секционирования - новые партиции автоматически: тоже не создаются.
Вакуумировать, анализировать таблицы-партиции надо отдельно, явно указывая их имя.

В декларативном секционировании: триггерный мех-м - спрятан под капот.
И, ключевое: изменён синтаксис добавления таблиц-партиций - теперь в самой ддл-команде определения партиции указывается - к какому именно диапазону значений ключа секционирования данная партиция относится.
Например:
```sql
CREATE TABLE measurement (
    city_id         int not null,
    logdate         date not null,
    peaktemp        int,
    unitsales       int
) PARTITION BY RANGE (logdate);

CREATE TABLE measurement_y2006m02 PARTITION OF measurement FOR VALUES FROM ('2006-02-01') TO ('2006-03-01');
...
CREATE TABLE measurement_y2007m12 PARTITION OF measurement FOR VALUES FROM ('2007-12-01') TO ('2008-01-01') TABLESPACE fasttablespace;
CREATE TABLE measurement_y2006m02 PARTITION OF measurement FOR VALUES FROM ('2006-02-01') TO ('2006-03-01') PARTITION BY RANGE (peaktemp);
```

Этим сразу же сообщается субд и sql-оптимизатору информация о том - где какие строки должны(или не должны) хранится и храняться.
И партишен-прунинг не обязательно обеспечивать на constraint_exclusion check-констрейнтах, хотя они и желательны.
Тем не менее, видимо для баквард-компатибилити, сделан параметр: `enable_partition_pruning` По дефолту: `on`
Есть аттач/детач партиций, аналог partition-exchange в oracle-субд.
Вакуумировать, анализировать таблицы-партиции надо, так же, отдельно, явно указывая их имя.

Новые партиции - автоматически не создаются, ни в каком виде секционирования.
Т.е. аналога интервального секционирования, как в oracle-субд, нет.
Но, как обычно, для этого есть пг-расширения, например [pg_partman](https://github.com/pgpartman/pg_partman)

Формулировка ДЗ: `Секционировать большую таблицу из демо базы flights`
Нашёл демо-базу, которая тут подразумевается, про авиаперевозки, на [сайте пгпро](https://postgrespro.com/education/demodb).

Установка демо-бд (!!! оно пересоздаёт базу DEMO !!!):
```shell
sudo su postgre
wget -O 1.zip https://edu.postgrespro.com/demo-small-en.zip
unzip 1.zip
psql -f demo-small-en-20170815.sql
```


